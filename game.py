"""DO NOT EDIT THIS FILE.
YOU DON'T NEED TO READ THIS FILE.

Useful function are documented and imported in the
provided `solver.py` template that you need to implement.

Main tetris game implementation. Handles game state, move making, and collision logic.
Inspired by: https://gist.github.com/silvasur/565419/d9de6a84e7da000797ac681976442073045c74a4
"""

# To make things look pretty.
colors = [
    (0, 0, 0),
    (255, 0, 0),
    (0, 150, 0),
    (0, 0, 255),
    (255, 120, 0),
    (255, 255, 0),
    (180, 0, 255),
    (0, 220, 220),
]

# fmt: off
tetris_shapes = {
    "T": [[1, 1, 1],
          [0, 1, 0]],
    
    "S": [[0, 2, 2],
          [2, 2, 0]],
    
    "SFlip": [[3, 3, 0],
              [0, 3, 3]],
    
    "L": [[4, 0, 0],
          [4, 4, 4]],
    
    "LFlip": [[0, 0, 5],
              [5, 5, 5]],
    
    "I": [[6, 6, 6, 6]],
    
    "O": [[7, 7],
          [7, 7]]
}
# fmt: on


def rotate_clockwise(shape):
    return [
        [shape[y][x] for y in range(len(shape))]
        for x in range(len(shape[0]) - 1, -1, -1)
    ]


def check_collision(board, shape, offset):
    off_x, off_y = offset
    for cy, row in enumerate(shape):
        for cx, cell in enumerate(row):
            try:
                if cell and board[cy + off_y][cx + off_x]:
                    return True
            except IndexError:
                return True
    return False


def join_matrixes(mat1, mat2, mat2_off):
    off_x, off_y = mat2_off
    for cy, row in enumerate(mat2):
        for cx, val in enumerate(row):
            mat1[cy + off_y - 1][cx + off_x] += val
    return mat1


class Board(object):
    def __init__(self, rows, columns):
        self.rows = rows
        self.columns = columns

        self._board = [[0 for x in range(self.columns)] for y in range(self.rows)]
        self._board += [[1 for x in range(self.columns)]]

    def copy(self):
        board = Board(self.rows, self.columns)
        board._board = [row[:] for row in self._board]
        return board

    def skyline(self):
        skyline = [0 for _ in range(self.columns)]
        last_row = self.rows - 1

        for column in range(self.columns):
            for row in range(self.rows):
                if self._board[row][column] != 0:
                    skyline[column] = self.rows - row
                    break

        return skyline

    def move(self, shape_name, x, rotation):
        shape = tetris_shapes[shape_name]

        for _ in range(rotation):
            shape = rotate_clockwise(shape)

        if x < 0 or x >= self.columns:
            raise ValueError("x has to be between 0 and number of columns-1.")

        if check_collision(self._board, shape, (x, 0)):
            raise ValueError("Invalid move!")

        final_y = self.rows - 1
        for y in range(self.rows):
            if check_collision(self._board, shape, (x, y)):
                final_y = y
                break

        try:
            self._board = join_matrixes(self._board, shape, (x, final_y))
        except IndexError:
            raise ValueError("Invalid move!")

    def print(self):
        for row in range(self.rows):
            row_string = "".join(
                [
                    "." if self._board[row][column] == 0 else "#"
                    for column in range(self.columns)
                ]
            )
            print(row_string)


def board_from_heights(heights, rows, columns):
    board = Board(rows, columns)

    for column, h in enumerate(heights):
        for row in range(rows - h, rows):
            board._board[row][column] = 1

    return board
